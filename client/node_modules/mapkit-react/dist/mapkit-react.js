import { jsx as P, jsxs as ke, Fragment as Fe } from "react/jsx-runtime";
import fe, { useState as te, useLayoutEffect as oe, useEffect as n, useRef as x, useImperativeHandle as je, useContext as ve, useMemo as De } from "react";
import { createPortal as he } from "react-dom";
var pe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, He = typeof pe == "object" && pe && pe.Object === Object && pe, Te = typeof self == "object" && self && self.Object === Object && self;
He || Te || Function("return this")();
var Ve = typeof window < "u" ? oe : n, Ke = typeof window > "u";
function We(e, i) {
  const c = typeof i == "boolean" ? i : (i == null ? void 0 : i.defaultValue) ?? !1, h = typeof i == "boolean" ? void 0 : (i == null ? void 0 : i.initializeWithValue) ?? void 0, M = (v) => Ke ? c : window.matchMedia(v).matches, [b, E] = te(() => h ? M(e) : c);
  function w() {
    E(M(e));
  }
  return Ve(() => {
    const v = window.matchMedia(e);
    return w(), v.addListener ? v.addListener(w) : v.addEventListener("change", w), () => {
      v.removeListener ? v.removeListener(w) : v.removeEventListener("change", w);
    };
  }, [e]), b;
}
const le = fe.createContext(null);
let me = null;
function xe(e) {
  return me !== null || (me = new Promise((i) => {
    const c = document.createElement("script");
    c.addEventListener("load", () => {
      mapkit.init({
        authorizationCallback: (h) => h(e)
      }), i();
    }, { once: !0 }), c.src = "https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.js", c.crossOrigin = "anonymous", document.head.appendChild(c);
  })), me;
}
var Ee = /* @__PURE__ */ ((e) => (e[e.Light = 0] = "Light", e[e.Dark = 1] = "Dark", e[e.Auto = 2] = "Auto", e))(Ee || {});
function Be(e, i) {
  switch (e) {
    case 1:
      return mapkit.Map.ColorSchemes.Dark;
    case 0:
      return mapkit.Map.ColorSchemes.Light;
    case 2:
      return i ? mapkit.Map.ColorSchemes.Dark : mapkit.Map.ColorSchemes.Light;
    default:
      throw new RangeError("Invalid color scheme");
  }
}
var ye = /* @__PURE__ */ ((e) => (e[e.Standard = 0] = "Standard", e[e.MutedStandard = 1] = "MutedStandard", e[e.Hybrid = 2] = "Hybrid", e[e.Satellite = 3] = "Satellite", e))(ye || {});
function Ne(e) {
  switch (e) {
    case 0:
      return mapkit.Map.MapTypes.Standard;
    case 1:
      return mapkit.Map.MapTypes.MutedStandard;
    case 2:
      return mapkit.Map.MapTypes.Hybrid;
    case 3:
      return mapkit.Map.MapTypes.Satellite;
    default:
      throw new RangeError("Invalid map type");
  }
}
function Ge(e) {
  return {
    centerLatitude: e.center.latitude,
    centerLongitude: e.center.longitude,
    latitudeDelta: e.span.latitudeDelta,
    longitudeDelta: e.span.longitudeDelta
  };
}
function Ze(e) {
  switch (e) {
    case mapkit.Map.MapTypes.Standard:
      return 0;
    case mapkit.Map.MapTypes.MutedStandard:
      return 1;
    case mapkit.Map.MapTypes.Hybrid:
      return 2;
    case mapkit.Map.MapTypes.Satellite:
      return 3;
    default:
      throw new RangeError("Invalid map type");
  }
}
var Ae = /* @__PURE__ */ ((e) => (e[e.Adaptive = 0] = "Adaptive", e[e.Metric = 1] = "Metric", e[e.Imperial = 2] = "Imperial", e))(Ae || {});
function ze(e) {
  switch (e) {
    case 0:
      return mapkit.Map.Distances.Adaptive;
    case 1:
      return mapkit.Map.Distances.Metric;
    case 2:
      return mapkit.Map.Distances.Imperial;
    default:
      throw new RangeError("Invalid distances value");
  }
}
var Re = /* @__PURE__ */ ((e) => (e[e.LandCover = 0] = "LandCover", e[e.PointsOfInterest = 1] = "PointsOfInterest", e[e.None = 2] = "None", e))(Re || {});
function Ce(e) {
  switch (e) {
    case 0:
      return mapkit.Map.LoadPriorities.LandCover;
    case 1:
      return mapkit.Map.LoadPriorities.PointsOfInterest;
    case 2:
      return mapkit.Map.LoadPriorities.None;
    default:
      throw new RangeError("Invalid load priority");
  }
}
function Se(e) {
  if (typeof e == "number") {
    if (e < 0 || e > 1e3)
      throw new RangeError("Display priority is out of range (0 to 1000)");
    return e;
  }
  switch (e) {
    case "low":
      return mapkit.Annotation.DisplayPriority.Low;
    case "high":
      return mapkit.Annotation.DisplayPriority.High;
    case "required":
      return mapkit.Annotation.DisplayPriority.Required;
    default:
      throw new RangeError("Invalid display priority");
  }
}
var ue = /* @__PURE__ */ ((e) => (e[e.Hidden = 0] = "Hidden", e[e.Visible = 1] = "Visible", e[e.Adaptive = 2] = "Adaptive", e))(ue || {});
function Me(e) {
  switch (e) {
    case 2:
      return mapkit.FeatureVisibility.Adaptive;
    case 1:
      return mapkit.FeatureVisibility.Visible;
    case 0:
      return mapkit.FeatureVisibility.Hidden;
    default:
      throw new RangeError("Invalid feature visibility");
  }
}
var Ue = /* @__PURE__ */ ((e) => (e[e.Airport = 0] = "Airport", e[e.AmusementPark = 1] = "AmusementPark", e[e.Aquarium = 2] = "Aquarium", e[e.ATM = 3] = "ATM", e[e.Bakery = 4] = "Bakery", e[e.Bank = 5] = "Bank", e[e.Beach = 6] = "Beach", e[e.Brewery = 7] = "Brewery", e[e.Cafe = 8] = "Cafe", e[e.Campground = 9] = "Campground", e[e.CarRental = 10] = "CarRental", e[e.EVCharger = 11] = "EVCharger", e[e.FireStation = 12] = "FireStation", e[e.FitnessCenter = 13] = "FitnessCenter", e[e.FoodMarket = 14] = "FoodMarket", e[e.GasStation = 15] = "GasStation", e[e.Hospital = 16] = "Hospital", e[e.Hotel = 17] = "Hotel", e[e.Laundry = 18] = "Laundry", e[e.Library = 19] = "Library", e[e.Marina = 20] = "Marina", e[e.MovieTheater = 21] = "MovieTheater", e[e.Museum = 22] = "Museum", e[e.NationalPark = 23] = "NationalPark", e[e.Nightlife = 24] = "Nightlife", e[e.Park = 25] = "Park", e[e.Parking = 26] = "Parking", e[e.Pharmacy = 27] = "Pharmacy", e[e.Police = 28] = "Police", e[e.PostOffice = 29] = "PostOffice", e[e.PublicTransport = 30] = "PublicTransport", e[e.Restaurant = 31] = "Restaurant", e[e.Restroom = 32] = "Restroom", e[e.School = 33] = "School", e[e.Stadium = 34] = "Stadium", e[e.Store = 35] = "Store", e[e.Theater = 36] = "Theater", e[e.University = 37] = "University", e[e.Winery = 38] = "Winery", e[e.Zoo = 39] = "Zoo", e))(Ue || {});
function be(e) {
  switch (e) {
    case 0:
      return mapkit.PointOfInterestCategory.Airport;
    case 1:
      return mapkit.PointOfInterestCategory.AmusementPark;
    case 2:
      return mapkit.PointOfInterestCategory.Aquarium;
    case 3:
      return mapkit.PointOfInterestCategory.ATM;
    case 4:
      return mapkit.PointOfInterestCategory.Bakery;
    case 5:
      return mapkit.PointOfInterestCategory.Bank;
    case 6:
      return mapkit.PointOfInterestCategory.Beach;
    case 7:
      return mapkit.PointOfInterestCategory.Brewery;
    case 8:
      return mapkit.PointOfInterestCategory.Cafe;
    case 9:
      return mapkit.PointOfInterestCategory.Campground;
    case 10:
      return mapkit.PointOfInterestCategory.CarRental;
    case 11:
      return mapkit.PointOfInterestCategory.EVCharger;
    case 12:
      return mapkit.PointOfInterestCategory.FireStation;
    case 13:
      return mapkit.PointOfInterestCategory.FitnessCenter;
    case 14:
      return mapkit.PointOfInterestCategory.FoodMarket;
    case 15:
      return mapkit.PointOfInterestCategory.GasStation;
    case 16:
      return mapkit.PointOfInterestCategory.Hospital;
    case 17:
      return mapkit.PointOfInterestCategory.Hotel;
    case 18:
      return mapkit.PointOfInterestCategory.Laundry;
    case 19:
      return mapkit.PointOfInterestCategory.Library;
    case 20:
      return mapkit.PointOfInterestCategory.Marina;
    case 21:
      return mapkit.PointOfInterestCategory.MovieTheater;
    case 22:
      return mapkit.PointOfInterestCategory.Museum;
    case 23:
      return mapkit.PointOfInterestCategory.NationalPark;
    case 24:
      return mapkit.PointOfInterestCategory.Nightlife;
    case 25:
      return mapkit.PointOfInterestCategory.Park;
    case 26:
      return mapkit.PointOfInterestCategory.Parking;
    case 27:
      return mapkit.PointOfInterestCategory.Pharmacy;
    case 28:
      return mapkit.PointOfInterestCategory.Police;
    case 29:
      return mapkit.PointOfInterestCategory.PostOffice;
    case 30:
      return mapkit.PointOfInterestCategory.PublicTransport;
    case 31:
      return mapkit.PointOfInterestCategory.Restaurant;
    case 32:
      return mapkit.PointOfInterestCategory.Restroom;
    case 33:
      return mapkit.PointOfInterestCategory.School;
    case 34:
      return mapkit.PointOfInterestCategory.Stadium;
    case 35:
      return mapkit.PointOfInterestCategory.Store;
    case 36:
      return mapkit.PointOfInterestCategory.Theater;
    case 37:
      return mapkit.PointOfInterestCategory.University;
    case 38:
      return mapkit.PointOfInterestCategory.Winery;
    case 39:
      return mapkit.PointOfInterestCategory.Zoo;
    default:
      throw new RangeError("Invalid point of interest category");
  }
}
function ge(e) {
  return new mapkit.CoordinateRegion(
    new mapkit.Coordinate(e.centerLatitude, e.centerLongitude),
    new mapkit.CoordinateSpan(e.latitudeDelta, e.longitudeDelta)
  );
}
function A(e, i, c, h) {
  n(() => {
    if (!e || !c)
      return;
    const M = (b) => {
      c(h(b));
    };
    return e.addEventListener(i, M), () => e.removeEventListener(i, M);
  }, [e, c]);
}
const $e = fe.forwardRef(({
  children: e = void 0,
  load: i,
  token: c,
  colorScheme: h = Ee.Light,
  mapType: M = ye.Standard,
  distances: b = Ae.Adaptive,
  loadPriority: E = Re.LandCover,
  isRotationEnabled: w = !0,
  isScrollEnabled: v = !0,
  isZoomEnabled: L = !0,
  showsCompass: H = ue.Adaptive,
  showsScale: T = ue.Hidden,
  showsMapTypeControl: B = !0,
  showsZoomControl: N = !0,
  showsUserLocationControl: G = !1,
  showsPointsOfInterest: m = !0,
  showsUserLocation: V = !1,
  tracksUserLocation: u = !1,
  allowWheelToZoom: K = !1,
  includedPOICategories: g = void 0,
  excludedPOICategories: F = void 0,
  paddingTop: s = 0,
  paddingRight: l = 0,
  paddingBottom: o = 0,
  paddingLeft: d = 0,
  initialRegion: y = void 0,
  cameraBoundary: R = void 0,
  minCameraDistance: W = 0,
  maxCameraDistance: X = 1 / 0,
  onLoad: Z = void 0,
  onRegionChangeStart: Y = void 0,
  onRegionChangeEnd: re = void 0,
  onMapTypeChange: ne = void 0,
  onSingleTap: ae = void 0,
  onDoubleTap: a = void 0,
  onLongPress: ie = void 0,
  onUserLocationChange: O = void 0,
  onUserLocationError: z = void 0,
  onClick: C = void 0,
  onMouseMove: r = void 0,
  onMouseDown: U = void 0,
  onMouseUp: j = void 0
}, Q) => {
  const [t, $] = te(null), D = x(null), I = x(!1);
  n(() => ((typeof i == "function" ? i : xe)(c).then(() => {
    if (I.current)
      return;
    const k = y ? { region: ge(y) } : {};
    $(new mapkit.Map(D.current, k)), I.current = !0;
  }), () => {
    t && (t.destroy(), I.current = !1);
  }), []), n(() => {
    t !== null && (Z == null || Z());
  }, [t]), je(Q, () => t, [t]);
  const p = We("(prefers-color-scheme: dark)");
  n(() => {
    t && (t.colorScheme = Be(h, p));
  }, [t, h, p]), n(() => {
    t && (t.mapType = Ne(M));
  }, [t, M]), n(() => {
    t && (t.distances = ze(b));
  }, [t, b]), n(() => {
    t && (t.loadPriority = Ce(E));
  }, [t, E]), Object.entries({
    isRotationEnabled: w,
    isScrollEnabled: v,
    isZoomEnabled: L,
    showsMapTypeControl: B,
    showsZoomControl: N,
    showsUserLocationControl: G,
    showsPointsOfInterest: m,
    showsUserLocation: V,
    tracksUserLocation: u
  }).forEach(([S, k]) => {
    n(() => {
      t && (t[S] = k);
    }, [t, k]);
  }), Object.entries({
    showsCompass: H,
    showsScale: T
  }).forEach(([S, k]) => {
    n(() => {
      t && (t[S] = Me(k));
    }, [t, k]);
  }), n(() => {
    if (t)
      try {
        t._allowWheelToZoom = K;
      } catch {
      }
  }, [t, K]), n(() => {
    t && (t.padding = new mapkit.Padding(s, l, o, d));
  }, [t, s, l, o, d]), n(() => {
    t && (t.cameraBoundary = R ? ge(R) : null);
  }, [t, R]), n(() => {
    t && (t.cameraZoomRange = new mapkit.CameraZoomRange(W, X));
  }, [t, W, X]), n(() => {
    if (t) {
      if (g && F)
        throw new Error("Canâ€™t specify both includedPOICategories and excludedPOICategories.");
      g ? t.pointOfInterestFilter = mapkit.PointOfInterestFilter.including(
        g.map(be)
      ) : F ? t.pointOfInterestFilter = mapkit.PointOfInterestFilter.excluding(
        F.map(be)
      ) : delete t.pointOfInterestFilter;
    }
  }, [t, g, F]);
  const de = () => Ge(t.region);
  A(t, "region-change-start", Y, de), A(t, "region-change-end", re, de), A(t, "map-type-change", ne, () => Ze(t.mapType));
  const f = ({ domEvents: S, pointOnPage: k }) => ({
    domEvents: S,
    pointOnPage: k,
    toCoordinates: () => t.convertPointOnPageToCoordinate(k)
  });
  return A(t, "single-tap", ae, f), A(t, "double-tap", a, f), A(t, "long-press", ie, f), A(t, "user-location-change", O, ({ coordinate: { latitude: S, longitude: k }, timestamp: ce, floorLevel: se }) => ({
    coordinate: { latitude: S, longitude: k },
    timestamp: ce,
    floorLevel: se
  })), A(t, "user-location-error", z, ({ code: S, message: k }) => ({ code: S, message: k })), [
    { name: "click", handler: C },
    { name: "mousemove", handler: r },
    { name: "mousedown", handler: U },
    { name: "mouseup", handler: j }
  ].forEach(({ name: S, handler: k }) => {
    n(() => {
      var se;
      if (!t || !k)
        return;
      const ce = (q) => {
        k({
          domEvents: [q],
          pointOnPage: { x: q.pageX, y: q.pageY },
          toCoordinates() {
            const { latitude: Le, longitude: Pe } = t.convertPointOnPageToCoordinate(new DOMPoint(q.pageX, q.pageY));
            return { latitude: Le, longitude: Pe };
          }
        });
      };
      return (se = D.current) == null || se.addEventListener(S, ce), () => {
        var q;
        return (q = D.current) == null ? void 0 : q.removeEventListener(S, ce);
      };
    }, [t, k]);
  }), /* @__PURE__ */ P(fe.StrictMode, { children: /* @__PURE__ */ P("div", { style: { width: "100%", height: "100%" }, ref: D, children: /* @__PURE__ */ P(le.Provider, { value: t, children: e }) }) });
}), _ = fe.forwardRef(({ children: e, type: i = "container" }, c) => /* @__PURE__ */ P("div", { className: `mk-callout-${i}`, ref: c, children: e }));
function Je({
  latitude: e,
  longitude: i,
  title: c = "",
  subtitle: h = "",
  accessibilityLabel: M = null,
  subtitleVisibility: b = ue.Adaptive,
  titleVisibility: E = ue.Adaptive,
  clusteringIdentifier: w = null,
  displayPriority: v = void 0,
  collisionMode: L = void 0,
  color: H = "#ff5b40",
  glyphColor: T = "white",
  glyphText: B = "",
  glyphImage: N = null,
  selectedGlyphImage: G = null,
  paddingTop: m = 0,
  paddingRight: V = 0,
  paddingBottom: u = 0,
  paddingLeft: K = 0,
  anchorOffsetX: g = 0,
  anchorOffsetY: F = 0,
  calloutElement: s = void 0,
  calloutContent: l = void 0,
  calloutLeftAccessory: o = void 0,
  calloutRightAccessory: d = void 0,
  calloutEnabled: y = void 0,
  calloutOffsetX: R = 0,
  calloutOffsetY: W = 0,
  selected: X = !1,
  animates: Z = !0,
  appearanceAnimation: Y = "",
  visible: re = !0,
  draggable: ne = !1,
  enabled: ae = !0,
  onSelect: a = void 0,
  onDeselect: ie = void 0,
  onDragStart: O = void 0,
  onDragEnd: z = void 0,
  onDragging: C = void 0
}) {
  const [r, U] = te(null), j = ve(le);
  n(() => {
    r && (r.subtitleVisibility = Me(b));
  }, [r, b]), n(() => {
    r && (r.titleVisibility = Me(E));
  }, [r, E]), n(() => {
    r && (r.padding = new mapkit.Padding(m, V, u, K));
  }, [r, m, V, u, K]), n(() => {
    r && (r.anchorOffset = new DOMPoint(g, F));
  }, [r, g, F]), n(() => {
    r && (r.calloutOffset = new DOMPoint(R, W));
  }, [r, R, W]);
  const Q = x(null), t = x(null), $ = x(null), D = x(null);
  oe(() => {
    if (!r)
      return;
    const f = {};
    return s && D.current !== null && (f.calloutElementForAnnotation = () => D.current), o && Q.current !== null && (f.calloutLeftAccessoryForAnnotation = () => Q.current), d && t.current !== null && (f.calloutRightAccessoryForAnnotation = () => t.current), l && $.current !== null && (f.calloutContentForAnnotation = () => $.current), Object.keys(f).length > 0 ? r.callout = f : delete r.callout, () => {
      delete r.callout;
    };
  }, [
    r,
    s,
    o,
    d,
    l,
    D.current,
    Q.current,
    t.current,
    $.current
  ]), n(() => {
    r && (L === "Circle" ? r.collisionMode = mapkit.Annotation.CollisionMode.Circle : L === "Rectangle" ? r.collisionMode = mapkit.Annotation.CollisionMode.Rectangle : delete r.collisionMode);
  }, [r, L]), n(() => {
    if (r) {
      if (v === void 0) {
        delete r.displayPriority;
        return;
      }
      r.displayPriority = Se(v);
    }
  }, [r, v]), Object.entries({
    title: c,
    subtitle: h,
    accessibilityLabel: M,
    color: H,
    glyphColor: T,
    glyphText: B,
    glyphImage: N,
    selectedGlyphImage: G,
    clusteringIdentifier: w,
    selected: X,
    animates: Z,
    appearanceAnimation: Y,
    draggable: ne,
    enabled: ae,
    visible: re,
    calloutEnabled: y
  }).forEach(([f, ee]) => {
    n(() => {
      if (r) {
        if (ee === void 0) {
          delete r[f];
          return;
        }
        r[f] = ee;
      }
    }, [r, ee]);
  });
  const p = () => {
  };
  [
    { name: "select", handler: a },
    { name: "deselect", handler: ie },
    { name: "drag-start", handler: O }
  ].forEach(({ name: f, handler: ee }) => {
    A(r, f, ee, p);
  });
  const we = () => ({
    latitude: r.coordinate.latitude,
    longitude: r.coordinate.longitude
  }), de = (f) => ({
    latitude: f.coordinate.latitude,
    longitude: f.coordinate.longitude
  });
  return A(r, "drag-end", z, we), A(r, "dragging", C, de), oe(() => {
    if (j === null)
      return;
    const f = new mapkit.MarkerAnnotation(
      new mapkit.Coordinate(e, i)
    );
    return j.addAnnotation(f), U(f), () => {
      j.removeAnnotation(f);
    };
  }, [j, e, i]), he(
    /* @__PURE__ */ ke("div", { style: { display: "none" }, children: [
      l !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: $,
          type: "content",
          children: l
        }
      ),
      o !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: Q,
          type: "left",
          children: o
        }
      ),
      d !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: t,
          type: "right",
          children: d
        }
      ),
      s !== void 0 && /* @__PURE__ */ P(
        _,
        {
          ref: D,
          type: "container",
          children: s
        }
      )
    ] }),
    document.body
  );
}
function Xe({
  latitude: e,
  longitude: i,
  title: c = "",
  subtitle: h = "",
  accessibilityLabel: M = null,
  size: b = void 0,
  paddingTop: E = 0,
  paddingRight: w = 0,
  paddingBottom: v = 0,
  paddingLeft: L = 0,
  anchorOffsetX: H = 0,
  anchorOffsetY: T = 0,
  selected: B = !1,
  onSelect: N = void 0,
  onDeselect: G = void 0,
  onDragStart: m = void 0,
  onDragEnd: V = void 0,
  onDragging: u = void 0,
  animates: K = !0,
  appearanceAnimation: g = "",
  visible: F = !0,
  clusteringIdentifier: s = null,
  displayPriority: l = void 0,
  collisionMode: o = void 0,
  calloutElement: d = void 0,
  calloutContent: y = void 0,
  calloutLeftAccessory: R = void 0,
  calloutRightAccessory: W = void 0,
  calloutEnabled: X = void 0,
  calloutOffsetX: Z = 0,
  calloutOffsetY: Y = 0,
  draggable: re = !1,
  enabled: ne = !0,
  children: ae
}) {
  const [a, ie] = te(null), O = De(() => document.createElement("div"), []), z = ve(le);
  n(() => {
    a && (a.padding = new mapkit.Padding(E, w, v, L));
  }, [a, E, w, v, L]), n(() => {
    a && (a.anchorOffset = new DOMPoint(H, T));
  }, [a, H, T]), n(() => {
    a && (a.calloutOffset = new DOMPoint(Z, Y));
  }, [a, Z, Y]);
  const C = x(null), r = x(null), U = x(null), j = x(null);
  oe(() => {
    if (!a)
      return;
    const p = {};
    return d && j.current !== null && (p.calloutElementForAnnotation = () => j.current), R && C.current !== null && (p.calloutLeftAccessoryForAnnotation = () => C.current), W && r.current !== null && (p.calloutRightAccessoryForAnnotation = () => r.current), y && U.current !== null && (p.calloutContentForAnnotation = () => U.current), Object.keys(p).length > 0 ? a.callout = p : delete a.callout, () => {
      delete a.callout;
    };
  }, [
    a,
    d,
    R,
    W,
    y,
    j.current,
    C.current,
    r.current,
    U.current
  ]), n(() => {
    a && (o === "Circle" ? a.collisionMode = mapkit.Annotation.CollisionMode.Circle : o === "Rectangle" ? a.collisionMode = mapkit.Annotation.CollisionMode.Rectangle : delete a.collisionMode);
  }, [a, o]), n(() => {
    if (a) {
      if (l === void 0) {
        delete a.displayPriority;
        return;
      }
      a.displayPriority = Se(l);
    }
  }, [a, l]), Object.entries({
    title: c,
    subtitle: h,
    accessibilityLabel: M,
    size: b,
    selected: B,
    animates: K,
    appearanceAnimation: g,
    draggable: re,
    enabled: ne,
    visible: F,
    clusteringIdentifier: s,
    calloutEnabled: X
  }).forEach(([p, J]) => {
    n(() => {
      if (a) {
        if (J === void 0) {
          delete a[p];
          return;
        }
        a[p] = J;
      }
    }, [a, J]);
  });
  const t = () => {
  };
  [
    { name: "select", handler: N },
    { name: "deselect", handler: G },
    { name: "drag-start", handler: m }
  ].forEach(({ name: p, handler: J }) => {
    A(a, p, J, t);
  });
  const D = () => ({
    latitude: a.coordinate.latitude,
    longitude: a.coordinate.longitude
  }), I = (p) => ({
    latitude: p.coordinate.latitude,
    longitude: p.coordinate.longitude
  });
  return A(a, "drag-end", V, D), A(a, "dragging", u, I), oe(() => {
    if (z === null)
      return;
    const p = new mapkit.Annotation(
      new mapkit.Coordinate(e, i),
      () => O
    );
    return z.addAnnotation(p), ie(p), () => {
      z.removeAnnotation(p);
    };
  }, [z, e, i]), /* @__PURE__ */ ke(Fe, { children: [
    he(
      /* @__PURE__ */ ke("div", { style: { display: "none" }, children: [
        y !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: U,
            type: "content",
            children: y
          }
        ),
        R !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: C,
            type: "left",
            children: R
          }
        ),
        W !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: r,
            type: "right",
            children: W
          }
        ),
        d !== void 0 && /* @__PURE__ */ P(
          _,
          {
            ref: j,
            type: "container",
            children: d
          }
        )
      ] }),
      document.body
    ),
    he(ae, O)
  ] });
}
function Ye({
  points: e,
  visible: i = !0,
  enabled: c = !0,
  selected: h = !1,
  onSelect: M = void 0,
  onDeselect: b = void 0,
  lineCap: E = "round",
  lineDash: w = [],
  lineDashOffset: v = 0,
  lineJoin: L = "round",
  lineWidth: H = 1,
  strokeColor: T = "rgb(0, 122, 255)",
  strokeOpacity: B = 1,
  strokeStart: N = 0,
  strokeEnd: G = 1
}) {
  const [m, V] = te(null), u = ve(le);
  return n(() => {
    if (u === null)
      return;
    const s = new mapkit.PolylineOverlay([]);
    return u.addOverlay(s), V(s), () => {
      u.removeOverlay(s);
    };
  }, [u]), n(() => {
    m !== null && (m.points = e.map(({ latitude: s, longitude: l }) => new mapkit.Coordinate(s, l)));
  }, [m, e]), Object.entries({ visible: i, enabled: c, selected: h }).forEach(([s, l]) => {
    n(() => {
      m && (m[s] = l);
    }, [m, l]);
  }), Object.entries({
    lineCap: E,
    lineDash: w,
    lineDashOffset: v,
    lineJoin: L,
    lineWidth: H,
    strokeColor: T,
    strokeOpacity: B,
    strokeStart: N,
    strokeEnd: G
  }).forEach(([s, l]) => {
    n(() => {
      m && (m.style[s] = l);
    }, [m, l]);
  }), [
    { name: "select", handler: M },
    { name: "deselect", handler: b }
  ].forEach(({ name: s, handler: l }) => {
    n(() => {
      if (!m || !l)
        return;
      const o = () => l();
      return m.addEventListener(s, o), () => m.removeEventListener(s, o);
    }, [m, l]);
  }), null;
}
function Oe({
  points: e,
  visible: i = !0,
  enabled: c = !0,
  selected: h = !1,
  onSelect: M = void 0,
  onDeselect: b = void 0,
  lineDash: E = [],
  lineDashOffset: w = 0,
  lineJoin: v = "round",
  lineWidth: L = 1,
  strokeColor: H = "rgb(0, 122, 255)",
  strokeOpacity: T = 1,
  strokeStart: B = 0,
  strokeEnd: N = 1,
  fillColor: G = "rgb(0, 122, 255)",
  fillOpacity: m = 0.1,
  fillRule: V = "nonzero"
}) {
  const [u, K] = te(null), g = ve(le);
  return n(() => {
    if (g === null)
      return;
    const o = new mapkit.PolygonOverlay([]);
    return g.addOverlay(o), K(o), () => {
      g.removeOverlay(o);
    };
  }, [g]), n(() => {
    if (u === null)
      return;
    if (!e || e.length === 0) {
      u.points = [];
      return;
    }
    const o = (d) => d.map(
      ({ latitude: y, longitude: R }) => new mapkit.Coordinate(y, R)
    );
    u.points = Array.isArray(e[0]) ? e.map(o) : o(e);
  }, [u, e]), Object.entries({ visible: i, enabled: c, selected: h }).forEach(([o, d]) => {
    n(() => {
      u && (u[o] = d);
    }, [u, d]);
  }), Object.entries({
    lineDash: E,
    lineDashOffset: w,
    lineJoin: v,
    lineWidth: L,
    strokeColor: H,
    strokeOpacity: T,
    strokeStart: B,
    strokeEnd: N,
    fillColor: G,
    fillOpacity: m,
    fillRule: V
  }).forEach(([o, d]) => {
    n(() => {
      u && (u.style[o] = d);
    }, [u, d]);
  }), [
    { name: "select", handler: M },
    { name: "deselect", handler: b }
  ].forEach(({ name: o, handler: d }) => {
    n(() => {
      if (!u || !d)
        return;
      const y = () => d();
      return u.addEventListener(o, y), () => u.removeEventListener(o, y);
    }, [u, d]);
  }), null;
}
export {
  Xe as Annotation,
  Ee as ColorScheme,
  Ae as Distances,
  ue as FeatureVisibility,
  Re as LoadPriority,
  $e as Map,
  ye as MapType,
  Je as Marker,
  Ue as PointOfInterestCategory,
  Oe as Polygon,
  Ye as Polyline
};
